"use strict";(self.webpackChunkdata_platform_playbook=self.webpackChunkdata_platform_playbook||[]).push([[4552],{643:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var n=t(4848),i=t(8453);const a={},r="Spike: Full-text address search with fuzzy matching.",o={id:"spikes/templates/example",title:"Spike: Full-text address search with fuzzy matching.",description:"Postgres Tools vs Elasticsearch",source:"@site/docs/spikes/templates/example.md",sourceDirName:"spikes/templates",slug:"/spikes/templates/example",permalink:"/Data-Platform-Playbook/spikes/templates/example",draft:!1,unlisted:!1,editUrl:"https://github.com/LBHackney-IT/data-platform-playbook/edit/master/docs/spikes/templates/example.md",tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Postgres Tools vs Elasticsearch",id:"postgres-tools-vs-elasticsearch",level:3},{value:"Objective",id:"objective",level:2},{value:"Considerations",id:"considerations",level:2},{value:"Findings",id:"findings",level:2},{value:"Postgres:",id:"postgres",level:3},{value:"Elasticsearch:",id:"elasticsearch",level:3}];function d(e){const s={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"spike-full-text-address-search-with-fuzzy-matching",children:"Spike: Full-text address search with fuzzy matching."})}),"\n",(0,n.jsx)(s.h3,{id:"postgres-tools-vs-elasticsearch",children:"Postgres Tools vs Elasticsearch"}),"\n",(0,n.jsx)(s.h2,{id:"objective",children:"Objective"}),"\n",(0,n.jsx)(s.p,{children:"We want to determine which tools or technologies would be best for us to use to implement a full-text address search with fuzzy matching. This spike focused on two possibilities:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Postgres tools: We have a live Postgres RDS instance with address data."}),"\n",(0,n.jsx)(s.li,{children:"Elasticsearch: It is a popular search engine & analytics tool."}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"considerations",children:"Considerations"}),"\n",(0,n.jsx)(s.p,{children:"For this spike, a few user scenarios were used to determine which tool would be appropriate in fulfilling our desired address matching requirements:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Free text search across all address lines, i.e. Line1, Line2, Line3 & Line4."}),"\n",(0,n.jsx)(s.li,{children:"Abbreviations of common street names (e.g. str, rd) are accepted."}),"\n",(0,n.jsx)(s.li,{children:"Spelling mistakes are allowed."}),"\n",(0,n.jsx)(s.li,{children:"Names with/ without an apostrophe return expected results."}),"\n",(0,n.jsx)(s.li,{children:"Variations in describing address, e.g. Flat A 100 Mare Street vs 100A Mare Street."}),"\n",(0,n.jsx)(s.li,{children:"Match proper names regardless of the words street, road, lane, etc. e.g Cromwell street query should also return Cromwell Avenue matches."}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"findings",children:"Findings"}),"\n",(0,n.jsx)(s.h3,{id:"postgres",children:"Postgres:"}),"\n",(0,n.jsx)(s.p,{children:"Postgres has quite a number of tools (or extensions) that we can install on our AWS RDS instance giving us the functionality that we want for our full-text search.\nWith Postgres we can:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Parse address strings into tokens (or lexemes). Tokenising should allow mapping of words in a query even if the way the user inputs the query varies e.g:","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Saved string: \u201cTry not to become a man of success, but rather try to become a man of value\u201d"}),"\n",(0,n.jsx)(s.li,{children:"Tokens (or lexemes) created: 'becom', 'man', 'rather', 'success', 'tri', 'valu'"}),"\n",(0,n.jsx)(s.li,{children:"User one query: \u201cTrying not to become a man of success\u201d"}),"\n",(0,n.jsx)(s.li,{children:"User two query: \u201cBecoming a valued man\u201d"}),"\n",(0,n.jsx)(s.li,{children:"Both queries (after tokenising as well) should return the saved string. Note: Tokenising removes stop words like e.g \u2018the\u2019, \u2018a\u2019, \u2018of\u2019, etc."}),"\n",(0,n.jsx)(s.li,{children:"We can structure how to get the most relevant matches first by adding rankings to specific columns when queried."}),"\n",(0,n.jsx)(s.li,{children:"We can add custom dictionaries that would hold any stop words we don\u2019t want to be ignored and can also hold synonyms for words e.g apartment vs flat. Str vs street."}),"\n",(0,n.jsx)(s.li,{children:"Entity framework has support for Postgres full-text searching.\nThis is a quick overview of what Postgres full-text searching can offer us. The documentation for implementing this is very extensive and detailed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"####Limitation\nCurrently AWS RDS doesn\u2019t support custom dictionaries. This is because custom dictionaries are created as files that need to be uploaded into the database. You currently can\u2019t do this in RDS which would affect synonym and stop word matching."}),"\n",(0,n.jsx)(s.p,{children:"####Suggestion\nIt might be possible to get around this by how we parse the user query i.e the parsed query for full-text search would use boolean operators, \u201cAND\u201d, \u201cOR\u201d, \u201cNOT\u201d. We would most likely use AND operations to get more relevant matches but there might be a way to use OR operators before certain abbreviations/synonyms but this would likely be custom code and could get a bit unwieldy. This also might result in more irrelevant matches but matches nonetheless whereas using just AND would return nothing."}),"\n",(0,n.jsx)(s.h3,{id:"elasticsearch",children:"Elasticsearch:"}),"\n",(0,n.jsx)(s.p,{children:"This is a search and analytics engine tool so has been designed to tackle the full-text searching to a specialised degree. To use Elasticsearch we would need to get the data we want to index into it but if we use AWS Elasticsearch this can be accomplished by DMS."}),"\n",(0,n.jsx)(s.p,{children:"Getting data in Elasticsearch also requires mapping, however, we don\u2019t need to transfer all the data in the database. Might need more clarification on this but it sounds like an efficient way is to only transfer and index the data related to address search queries e.g the address line columns and postcode."}),"\n",(0,n.jsx)(s.p,{children:"Elasticsearch also can:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Parse address strings into tokens (or lexemes) using its analysers."}),"\n",(0,n.jsx)(s.li,{children:"Can install packages that add custom dictionaries of synonyms or words to ignore or stop words to not ignore."}),"\n",(0,n.jsx)(s.li,{children:"Can also add weights for ranking.\nElasticsearch comes with an extensive toolset for searching, analysing data and returning the relevant matches and can be integrated into dotnet project by using a package called NEST."}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"####Limitation\nThis is would be a separate tool that requires configuration and some understanding of what we should implement and don\u2019t need from Elasticsearch."}),"\n",(0,n.jsx)(s.p,{children:"AWS has an Elasticsearch service we could spin up in our AWS environments. If we use AWS Elasticsearch we can benefit from using DMS to get the data we need into it, however, if we do not use AWS Elasticsearch, we would need to create a script to import the data into our Elasticsearch instance."}),"\n",(0,n.jsx)(s.p,{children:"Using AWS Elasticsearch means we\u2019ll be adding an additional tool to our current stack in AWS and this would need to be managed and maintained. It also means that we would be adding an additional cost to the running of the stack. There is a free tier option but we would be charged for usages over that limit."}),"\n",(0,n.jsx)(s.p,{children:"####Suggestion\nFrom reading the ONS paper on address matching, Elasticsearch was being implemented for retrieving addresses. Since this paper was focused on tackling the address matching problem, it might be worth using this as a tool for indexing and searching rather than relying on database tools."}),"\n",(0,n.jsx)(s.p,{children:"We currently have indexes in the Postgres DB but it might be worth understanding a bit more about the indexing in Elasticsearch and whether these would have an effect on query performance compared to what we have in Postgres."}),"\n",(0,n.jsx)(s.p,{children:"In our case, we might be able to use Elasticsearch as our indexing tool for a subset of data, retrieve a list of matching ids and then query the database using these ids, which could result in faster retrieval but this needs to be checked."}),"\n",(0,n.jsx)(s.p,{children:"##Helpful Resources/Documentation"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Postgres documentation on Full-Text Searching"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Postgres Full-Text Search with Entity Framework Core"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Postgres full-text search is Good Enough! Blog"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Postgres Full-Text Search How-To Video"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Setting up Elasticsearch with .Net and Docker Blog"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Amazon Elasticsearch Pricing"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Amazon Elasticsearch Overview"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Querying Elasticsearch using the Search API"}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Using DMS to migrate data into Elasticsearch"}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>o});var n=t(6540);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);